1.临界区用来表示一种公共资源或者说是共享数据,可被多个线程使用.但是每一次,只能有一个线程使用它,一旦临界区资源被占用,其他线程要想使用这个资源,就必须等待.

2.若一个线程占用了临界区资源,那么其他所有需要这个资源的线程就必须在这个临界区中等待.等待会导致线程挂起,这种情况就是阻塞.

3.饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源,导致一直无法执行.比如它的线程优先级可能太低,而高优先级的线程不断抢占它需要的资源,导致低优先级线程无法工作.

4.阻塞的控制方式是悲观策略,系统认为两个线程之间很有可能发生冲突,因此以保护共享数据为第一优先级.非阻塞的调度是一种乐观策略,它认为多个线程之间发生冲突的概率不大,因此大家都应该无障碍地执行,但一旦检测到冲突,就应该进行回滚.

5.一种可行的无障碍实现可以依赖一个"一致性标记"来实现.线程在操作之前,先读取并保存这个标记,在操作完成后,再次读取,检查这个标记是否被更改过,若果两者是一致的则说明资源访问没有冲突.而所有对资源有修改的线程,在修改数据前,都需要更新这个一致性标记,表示数据不再安全.

6.无锁的并行都是无障碍的.

7.在无锁的调用中,一个典型的特点是可能会包含一个无穷循环.在这个循环中,线程会不断尝试修改共享变量.如果没有冲突,修改成功,程序退出否则继续尝试.

8.无锁只要求一个线程可以在有限步内完成,而无等待则在无锁的基础上更进一步进行扩展.它要求所有的线程都必须在有限步内完成,这样就不会引起饥饿问题.

9.使用并行的目的:1.提高运行效率,2.符合业务模型的需要

10.多线程的原子性是指一个操作是不可中断的,即使多个线程一起执行,一个操作一旦开始,就不会被其他线程干扰.可见性是指当一个线程修改了某一个共享变量的值,其他线程是否能够立即知道这个修改.缓存优化或者硬件优化,指令重排以及编辑器的优化,都可能会导致一个线程的修改不会立即被其他线程察觉.有序性问题的原因时因为程序在执行时,可能会进行指令重排,重排后的指令与原指令的顺序未必一致.注意:指令重排可以保证串行语义一致,但是没有义务保证多线程间的语义也一致.指令重排对于提高CPU处理性能是十分必要的.

11.指令重排不可违背的原则:程序顺序原则,volatile原则,锁规则,传递性,线程的start()方法先于它的每一个动作,线程的所有操作先于线程的终结,线程的中断先于被中断线程的代码,对象的构造函数执行 结束先于finalize()方法.


